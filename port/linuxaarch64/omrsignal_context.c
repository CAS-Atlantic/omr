/*******************************************************************************
 * Copyright (c) 2018, 2018 IBM Corp. and others
 *
 * This program and the accompanying materials are made available under
 * the terms of the Eclipse Public License 2.0 which accompanies this
 * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
 * or the Apache License, Version 2.0 which accompanies this distribution and
 * is available at https://www.apache.org/licenses/LICENSE-2.0.
 *
 * This Source Code may also be made available under the following
 * Secondary Licenses when the conditions for such availability set
 * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
 * General Public License, version 2 with the GNU Classpath
 * Exception [1] and GNU General Public License, version 2 with the
 * OpenJDK Assembly Exception [2].
 *
 * [1] https://www.gnu.org/software/classpath/license.html
 * [2] http://openjdk.java.net/legal/assembly-exception.html
 *
 * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
 *******************************************************************************/

#define _GNU_SOURCE

#include <sys/ucontext.h>
#include <unistd.h>

#include "omrport.h"
#include "omrsignal_context.h"

// TODO:AARCH64 find the right struct for <sys/sigcontext.h>

void
fillInUnixSignalInfo(struct OMRPortLibrary *portLibrary, void *contextInfo, struct OMRUnixSignalInfo *j9Info)
{
	j9Info->platformSignalInfo.context = (ucontext_t *)contextInfo;
	/* module info is filled on demand */
}

uint32_t
infoForSignal(struct OMRPortLibrary *portLibrary, struct OMRUnixSignalInfo *info, int32_t index, const char **name, void **value)
{
	*name = "";

	switch (index) {

	case OMRPORT_SIG_SIGNAL_TYPE:
	case 0:
		*name = "J9Generic_Signal_Number";
		*value = &info->portLibrarySignalType;
		return OMRPORT_SIG_VALUE_32;

	case OMRPORT_SIG_SIGNAL_PLATFORM_SIGNAL_TYPE:
	case 1:
		*name = "Signal_Number";
		*value = &info->sigInfo->si_signo;
		return OMRPORT_SIG_VALUE_32;

	case OMRPORT_SIG_SIGNAL_ERROR_VALUE:
	case 2:
		*name = "Error_Value";
		*value = &info->sigInfo->si_errno;
		return OMRPORT_SIG_VALUE_32;

	case OMRPORT_SIG_SIGNAL_CODE:
	case 3:
		*name = "Signal_Code";
		*value = &info->sigInfo->si_code;
		return OMRPORT_SIG_VALUE_32;

	case OMRPORT_SIG_SIGNAL_HANDLER:
	case 4:
		*name = "Handler1";
		*value = &info->handlerAddress;
		return OMRPORT_SIG_VALUE_ADDRESS;

	case 5:
		*name = "Handler2";
		*value = &info->handlerAddress2;
		return OMRPORT_SIG_VALUE_ADDRESS;

	case OMRPORT_SIG_SIGNAL_INACCESSIBLE_ADDRESS:
	case 6:
		/* si_code > 0 indicates that the signal was generated by the kernel */
		if (info->sigInfo->si_code > 0) {
			if ((info->sigInfo->si_signo == SIGBUS) || (info->sigInfo->si_signo == SIGSEGV)) {
				*name = "InaccessibleAddress";
				*value = &info->sigInfo->si_addr;
				return OMRPORT_SIG_VALUE_ADDRESS;
			}
		}
		return OMRPORT_SIG_VALUE_UNDEFINED;

	default:
		return OMRPORT_SIG_VALUE_UNDEFINED;
	}
}

uint32_t
infoForFPR(struct OMRPortLibrary *portLibrary, struct OMRUnixSignalInfo *info, int32_t index, const char **name, void **value)
{
	switch (index) {
	default:
		return OMRPORT_SIG_VALUE_UNDEFINED;
	}
}

uint32_t
infoForGPR(struct OMRPortLibrary *portLibrary, struct OMRUnixSignalInfo *info, int32_t index, const char **name, void **value)
{
	struct sigcontext *const context = (struct sigcontext *)&info->platformSignalInfo.context->uc_mcontext;
	*name = "";

	// excel cmd -> =CONCATENATE("case OMRPORT_SIG_GPR_AARCH64_R",A1,":",CHAR(10),"case ",A1,":",CHAR(10),"*name=",CHAR(34),"R",A1,CHAR(34),";",CHAR(10),"*value=&context->regs[",A1,"];",CHAR(10),"return OMRPORT_SIG_VALUE_ADDRESS;")
	switch (index) {
	case OMRPORT_SIG_GPR_AARCH64_R0:
	case 0:
		*name="R0";
		*value=&context->regs[0];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R1:
	case 1:
		*name="R1";
		*value=&context->regs[1];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R2:
	case 2:
		*name="R2";
		*value=&context->regs[2];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R3:
	case 3:
		*name="R3";
		*value=&context->regs[3];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R4:
	case 4:
		*name="R4";
		*value=&context->regs[4];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R5:
	case 5:
		*name="R5";
		*value=&context->regs[5];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R6:
	case 6:
		*name="R6";
		*value=&context->regs[6];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R7:
	case 7:
		*name="R7";
		*value=&context->regs[7];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R8:
	case 8:
		*name="R8";
		*value=&context->regs[8];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R9:
	case 9:
		*name="R9";
		*value=&context->regs[9];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R10:
	case 10:
		*name="R10";
		*value=&context->regs[10];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R11:
	case 11:
		*name="R11";
		*value=&context->regs[11];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R12:
	case 12:
		*name="R12";
		*value=&context->regs[12];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R13:
	case 13:
		*name="R13";
		*value=&context->regs[13];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R14:
	case 14:
		*name="R14";
		*value=&context->regs[14];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R15:
	case 15:
		*name="R15";
		*value=&context->regs[15];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R16:
	case 16:
		*name="R16";
		*value=&context->regs[16];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R17:
	case 17:
		*name="R17";
		*value=&context->regs[17];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R18:
	case 18:
		*name="R18";
		*value=&context->regs[18];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R19:
	case 19:
		*name="R19";
		*value=&context->regs[19];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R20:
	case 20:
		*name="R20";
		*value=&context->regs[20];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R21:
	case 21:
		*name="R21";
		*value=&context->regs[21];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R22:
	case 22:
		*name="R22";
		*value=&context->regs[22];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R23:
	case 23:
		*name="R23";
		*value=&context->regs[23];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R24:
	case 24:
		*name="R24";
		*value=&context->regs[24];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R25:
	case 25:
		*name="R25";
		*value=&context->regs[25];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R26:
	case 26:
		*name="R26";
		*value=&context->regs[26];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R27:
	case 27:
		*name="R27";
		*value=&context->regs[27];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R28:
	case 28:
		*name="R28";
		*value=&context->regs[28];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R29:
	case 29:
		*name="R29";
		*value=&context->regs[29];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R30:
	case 30:
		*name="R30";
		*value=&context->regs[30];
		return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_GPR_AARCH64_R31:
	case 31:
		*name="R31";
		*value=&context->regs[31];
		return OMRPORT_SIG_VALUE_ADDRESS;
	default:
		return OMRPORT_SIG_VALUE_UNDEFINED;
	}

}

uint32_t
infoForControl(struct OMRPortLibrary *portLibrary, struct OMRUnixSignalInfo *info, int32_t index, const char **name, void **value)
{
	struct sigcontext *const context = (struct sigcontext *)&info->platformSignalInfo.context->uc_mcontext;
	*name = "";

	switch (index) {
	case OMRPORT_SIG_CONTROL_PC:
	case 0:
		*name = "PC"; /* R11 */
		*value = (void *)&(context->pc);	// TODO:AARCH64 double check
		return OMRPORT_SIG_VALUE_ADDRESS;
	// case 1:
	// 	*name = "IP"; /* R12 */
	// 	*value = (void *)&(context->arm_ip);
	// 	return OMRPORT_SIG_VALUE_ADDRESS;
	case OMRPORT_SIG_CONTROL_SP:
	case 2:
		*name = "SP"; /* R13 */
		*value = (void *)&(context->sp);
		return OMRPORT_SIG_VALUE_ADDRESS;
	// case 3:
	// 	*name = "LR"; /* R14 */
	// 	*value = (void *)&(context->arm_lr);
	// 	return OMRPORT_SIG_VALUE_ADDRESS;
	// case 4:
	// 	*name = "PC"; /* R15 */
	// 	*value = (void *)&(context->arm_pc);
	// 	return OMRPORT_SIG_VALUE_ADDRESS;
	case 5:
		*name = "PSTATE";
		*value = (void *)&(context->pstate);
		return OMRPORT_SIG_VALUE_ADDRESS;
	default:
		return OMRPORT_SIG_VALUE_UNDEFINED;
	}
}

uint32_t
infoForModule(struct OMRPortLibrary *portLibrary, struct OMRUnixSignalInfo *info, int32_t index, const char **name, void **value)
{
	void *address;
	Dl_info *dl_info = &(info->platformSignalInfo.dl_info);
	struct sigcontext *context = (struct sigcontext *)&info->platformSignalInfo.context->uc_mcontext;
	*name = "";

	address = (void *)context->pc;
	int dl_result = dladdr(address, dl_info);

	switch (index) {
	case OMRPORT_SIG_MODULE_NAME:
	case 0:
		*name = "Module";
		if (dl_result) {
			*value = (void *)(dl_info->dli_fname);
			return OMRPORT_SIG_VALUE_STRING;
		}
		return OMRPORT_SIG_VALUE_UNDEFINED;
	case 1:
		*name = "Module_base_address";
		if (dl_result) {
			*value = (void *)&(dl_info->dli_fbase);
			return OMRPORT_SIG_VALUE_ADDRESS;
		}
		return OMRPORT_SIG_VALUE_UNDEFINED;
	case 2:
		*name = "Symbol";
		if (dl_result) {
			if (dl_info->dli_sname != NULL) {
				*value = (void *)(dl_info->dli_sname);
				return OMRPORT_SIG_VALUE_STRING;
			}
		}
		return OMRPORT_SIG_VALUE_UNDEFINED;
	case 3:
		*name = "Symbol_address";
		if (dl_result) {
			*value = (void *)&(dl_info->dli_saddr);
			return OMRPORT_SIG_VALUE_ADDRESS;
		}
		return OMRPORT_SIG_VALUE_UNDEFINED;
	default:
		return OMRPORT_SIG_VALUE_UNDEFINED;
	}
}
